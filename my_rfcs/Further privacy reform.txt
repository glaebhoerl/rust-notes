- Start Date: 2014-07-17
- RFC PR #: (leave this empty)
- Rust Issue #: (leave this empty)


# Summary

Make a distinction in the language between types which are "just data" (such as `Option`, `Ordering`, and `Point`) and types which represent abstraction boundaries (such as `Box`, `Cell`, `HashMap`, and `Vec`). The built-in traits are automatically propagated over "just data" types, and have to be explicitly re-introduced at abstraction boundaries. Doing so improves abstraction, modularity, safety, and convenience, and also eliminates a soundness violation in the current language.

Potentially also: 

 * Generalize the mechanism for the current built-in traits, enabling them to be implemented in library code.
 
 * Add "closed traits" with private-by-default methods.

 
# Motivation

Rust has recently run into an issue where convenience and correctness are seemingly at odds: if the built-in traits (`Copy`, `Send`, `Sync`) are automatically derived for types based on their contents, then types which use private fields and `unsafe` code behind the scenes become unsafe by default; while if they need to be derived or `impl`ed explicitly, then simple data types like `struct Point { x: int, y: int }` become laborious to "fully declare", whereas one would like them to "just work". There were suggestions to distinguish between types which have `priv` fields and ones which don't, but it seems surprising that adding or removing a `priv` field would affect the behavior of the type in such a way.

Rust is not the only language which has encountered this problem: recently, so has Haskell. The issue in Haskell's case is quite similar, and arose after they, like us, added a built-in, automatically derived trait. In their case, this was the `Coercible` type class (which served as the basis for the similarly-named proposal for Rust). In Haskell's case, the dilemma was about having to declare the roles of type parameters. If a type parameter has a representational role, it can be `coerce`d (transmuted) to a different type with the same representation (e.g. a `newtype`). Type parameters with a nominal role, however, cannot. If the default is for type parameters to be representational, then this means, for instance, that types like `Map k v` and `Set k` can be transmuted to different key types with different `Ord` instances, breaking their internal invariants, unless the library author adds explicit nominal role annotations to prevent this. On the other hand, if nominal is the default, then every "plain old" generic datatype would need representational role annotations to become useful with `Coercible`, which most of them want to be, and this would be quite burdensome. There were some suggestions to make the default depend on whether the type's constructors are exported from the module, but this was considered to be inappropriate, because role annotations live at the type system level, while exports and imports are a more primitive, module (name resolution) level mechanism. [This discussion from the GHC bug tracker](https://ghc.haskell.org/trac/ghc/ticket/8827) is worth reading in full.

In each case, the problem is that the language has no notion of abstraction boundaries at the semantic level, and only provides the programmer with the primitive mechanism of selectively exporting names from a module for maintaining internal invariants. However, the programmer *knows* whether she intends a type to be "just data" or to represent an abstraction boundary: she just has no good way to express this to the compiler.

The solution is therefore straightforward: Add a way!


also note that the **exact** same problem as Haskell+Coercible will also recur for us when we add Transmute if we don't do this


connection between abstraction and safety:
internal invariants are sometimes "just" correctness, but sometimes (with `unsafe` code) also implicate memory safety
if correctness is always maintained, then safety is also always maintained
if correctness can be violated, then safety can also be violated where `unsafe` code is involved
=> let's just maintain correctness


Also:

 * Adding or removing private `struct` fields should never break client code. Modules which can't see private fields should not be able to indirectly observe/detect/depend on their presence or absence.

 * The default should always be safety and correctness, it shouldn't be opt-in.
 
 * Functional struct updates currently subvert abstraction, and thus safety ([#???][github-issue]). This should be fixed.

 * It should be convenient to create types which are "just data" (such as the usual `struct Point`) and behave like you expect, without having to decorate them with annotations like a Christmas tree.

 * `enum` variants should be private by default, like everything else.

  * Can write abstract unit struct types w/o a dummy private field.


[github-issue]:

FSU issue:

    let v = vec![box 666i];
    Vec { ..v };
    println!("{}", v.get(0)); // boom


# Detailed design

core idea: syntactically and behaviorally distinguish data types from abstract types

multiple variations/flavors on syntax and semantics, I am happy with any of them
don't want to pre-commit, because other people probably do care, but this should *not* be what decides fate of proposal
(i.e. it's a free parameter)


## Syntactic variations

Concept           | Syntax A          | Syntax B      | Syntax C
----------------- | ----------------- | ------------- | ----------

"data struct"     | `struct`          | `data struct` | `struct`

"data enum"       | `enum`            | `data enum`   | `enum`

"abstract struct" | `abstract struct` | `struct`      | `class`

"abstract enum"   | `abstract enum`   | `enum`        | `enum class`??? or nothing

(other possible words: sealed, closed, opaque, internal, ...)

A:
 + plain `struct` and `enum` are the same as in C
 - wrong defaults (private is more syntax than public)

B:
 + right defaults (modifier needed to expose, rather than to hide)
 - plain `struct` and `enum` behave differently from C (equiv. to C is `data struct`, `data enum`)

C:
 + plain `struct` and `enum are the same as in C
 + `struct` vs. `class` distinction is evocative and has history
 0 no "defaults" (same amount of syntax)
 - `struct` vs. `class` may evoke the wrong thing: similar in spirit to C++, different from C#, D, and Swift
 - doesn't easily extend to `enum`s


will generally refer to them as just "data type" and "abstract type", w/o using concrete syntax


## Semantic variations


### Things in common

built-in traits `Copy`, `Send`, and `Sync` are automatically derived for data types

must be explicitly impled/derived for abstract types

in the future: ditto for `Transmute`, & possibly extensible to user traits


fields & constructors & variants of data types are all public (by default & always)

fields & constructors & variants of abstract types are private by default
can make individual fields of abstract structs `pub`
(but not individual enum variants - no known use case)


### Simpler formulation

Outside of owning module:

 * Constructors of abstract types may not be used at all

 * No literals, no FSU, no pattern matching

 * Individual `pub` fields of abstract structs only allow for access with dot-notation: `my_abstract_struct.some_field`

Individual `pub` fields on tuple structs are removed 
  data tuple struct => all fields public, abstract tuple struct => all fields private

Solves FSU problem, no further action required


### More sophisticated formulation

Outside owning module:

 * No literals of abstract types 

 * Pattern matching is allowed, but _always_ requires a wildcard (even if all individual fields are marked `pub`!)

Individual `pub` fields in abstract tuple structs must all be at the front, before all private ones

Need some kind of additional restriction on FSU to solve `Vec { ..v }` problem:

  * `v` is considered moved from(?)

  * the wildcard-fields are considered to not be `Copy`(?)

  * forbid FSU on types with Drop (does this solve the problem??)

  * forbid FSU period

Related question of whether `S { a: foo, b: bar, ..other }` should be interpreted as:

  * `S { a: foo, b: bar, c: other.c, d: other.d, e: other.e }` (move individual fields), or

  * `{ let result = other; other.a = foo; other.b = bar; result }` (move whole struct A), or

  * `{ let S { c, d, e, .. } = other; S { a: foo, b: bar, c: c, d: d, e: e } }` (move whole struct B)



Not 100% confident there aren't any further problems lurking. Would personally prefer more obvious simpler formulation.


This is the bulk of the RFC. Explain the design in enough detail for somebody familiar
with the language to understand, and for somebody familiar with the compiler to implement.
This should get into specifics and corner-cases, and include examples of how the feature is used.



### Optional add-on: `data trait` to allow traits like the built-in traits in libraries

empty, non-generic trait

 * automatically derived for all built-in types which don't conceptually require abstraction barriers to implement
   (i.e. which are equivalent to just a big ADT)
   u8..u64, i8..i64, int, uint, bool, char; [T, ..N] and tuples if contained type(s) also satisfy; but *not* &, &mut
   what about `fn`, *T?
 * automatically derived for user data types whose members all implement the given `data trait` (same as for current built-in traits)
 * must be explicitly implemented/derived for built-in & user abstract types (incl. `&`, `&mut`)

QUESTION if I declare a `data trait Foo` and `impl<T> Foo for std::Box<T>` (type I don't own), should it check the private fields of `Box<T>` for compliance?
  (a) always check private fields                                => breaks abstraction
  (b) never check private fields                                 => breaks safety
  (c) check private fields, but only allow impl in owning module => breaks modularity/compositionality/flexibility/whatever

Likely resolution:
 * `#deriving` checks private fields, only allowed in owning module (attached to type), is safe.
 * Outside owning module, can only `unsafe impl`, does not check private fields.
This probably applies in general to all data/unsafe traits (also e.g. `Any`/`Typeable`/`Dynamic`, `Trace`): 
  The compiler knows how to generate safe impls!
  Only user impls need to be explicitly trusted.

What's the relationship between `data trait` and `unsafe trait`??

Also being able to write `Box<Trait + DataTrait>`, w/o vptr for DataTrait... should this be extended to all empty traits? or just data traits?

Also the thing that incoherence is OK for empty traits: should it be allowed for all empty traits? or permitted explicitly?

So: a number of related capabilities, not clear how they should be organized

+ nice mnemonic (but only with the `data struct` / `data enum` syntax)

+ simple, solves the problem

- narrowly targetted

- not obvious that this is the best long-term solution (w.r.t. above question of capability organization & others)

recommendation: maybe behind a feature gate?

Potential more general longer-term solution:
more general datatype-generics system (~ GHC.Generics)
impl your trait for primitive/built-in/abstract types
impl it for anonymous products: tuples, & for anonymous sums (e.g. (A|B|C))
(what about exponentials i.e. functions?)
=> then derive it automatically for same-shape named data types via Transmute
and derive it explicitly for abstract types (again via Transmute)
something along these lines, right formulation not 100% obvious


### Optional add-on: closed traits

TODO link to motivation from no-privates-in-public

only real up-front question is syntax

`abstract trait`?? `trait class`?? sealed, closed, ...

Core of it is just: 
  * can only write `impl`s in owning module
  * methods are private unless marked `pub`

(completely analogous: trait ~ generic abstract struct w/ function ptr fields, impl ~ static instance of struct, can only be constructed in owning module)


In the future: Knowing that the set of impling types is closed lets you do a _lot_ of things!!

Improvement of types in type inference!
    http://research.microsoft.com/en-us/um/people/simonpj/papers/oo-haskell/overloading.pdf
    Problem of single impl `impl<T: ClosedTrait> ClosedTrait for Foo<T> { }` leads to infinite improvement loop...
    Solution in paper: ban closed traits as supertrait constraints. This seems excessive. Seems better to e.g. require a base case.

Overlap/specialization! 
    Would this violate coherence? According to paper: no!
    https://github.com/rust-lang/meeting-minutes/blob/master/workweek-2014-08-18/library-experience-report.md
    OK to do overlap/specialization as long as all impls are in same place!
    Question of how impl is selected: best match or first match?
    First match is more flexible, but requires impls be clearly ordered
    (in theory we could even offer both separately w/ different syntax, if there's any reason to want that)

If the set of types is closed, they have a statically known max size+alignment!
    So: can store closed trait objects unboxed!
    Could also e.g. switch-on-tag instead of virtual call.
    Maybe this is how you implement "union types"? (exceptions rfc)
      A union type (A|B|C|...) is just a closed trait implemented for exactly the listed types?
      (the hard part is getting (C|A) to be a subtrait of (A|B|C)... so still need some magic)

And what's the connection between closed trait objects and enums?
(Also, datasort refinements... hmm.)
Would we allow "matching" on a closed trait object to figure out which type it is?
Or should this be a distinct capability layered on top?

Important: set of impls is finite, but set of _types which impl_ may not be!!
    closed trait Foo { ... } 
    impl<T> Foo for T { ... }
    => oops
    but this is probably manageable somehow
    should still be able to _determine_ if the set of types is finite, whether they have an upper bound on size, etc...
    alternately, maybe can impose some kind of restrictions?
      might this be connected to `ref` (EQT)...? 
      something like: the impl _head_ may not mention the type unboxed (same as the `ref` restriction)... but where does the `ref` go? trait? impl?
      maybe this rule: "type parameters of closed trait `impl`s must be either `ref` or bounded by a closed trait"?
      => this would ensure a fixed max bound on size, but not on set-of-impling-types
    but maybe would be better to keep restricted/unrestricted separate w/ some explicit syntax to require restriction, or infer when it's satisfied
    experience will tell

Turns out that closed traits might be even more important than closed structs / enums...

(TODO: re-inspect various unify-enum-and-struct, virtual-struct etc. proposals to see whether they boil down to similar ideas)




# Drawbacks

An additional distinction that has to be learned. **But** this is essential/inherent complexity, and we are faithfully modelling it. User programs will thank us.

Adds a keyword (`data`, `abstract`, or `class`).



Why should we *not* do this?


# Alternatives

status quo blah blah

What other designs have been considered? What is the impact of not doing this?


# Unresolved questions

syntax A, B, or C

simpler or more sophisticated semantics formulation

whether to add `data trait`

whether to add closed traits (what to call them)



What parts of the design are still TBD?


# Future work

? explicit variance annotations for abstract types (if we can't just get rid of variances)

