SUBMITTED
Checked arithmetic
Ban private items in public APIs
Turn capitalization conventions into language rules for 1.0
Change `extern "ABI"` to `extern<ABI>` or `extern ABI`
Use `for` to introduce universal quantification

TODO
Further privacy reform (`data struct`, `data enum`, or `class`)
Existentially Quantified Types
Deconflate types and modules
Purity
Exceptions
Allow #attr and #attr(foo) but still require #[attr = foo]
Inline modules use normal scoping

trait Transmute
Garbage collection (trait Trace)
&out
&move

DISCOURSE?
`box`
Deterministic name resolution
Macro reform
Intrusive datastructures, unmovable types
Linear types
Philosophy

# RFCs
  # MAJOR
    * Existentially Quantified Types (IN PROGRESS)
      * `struct Foo<T: Trait>` `&Foo` for thin pointer to structs with internal vtables
      * String literals are unboxed rvalues
      * ...
    * Purity for (almost) free (FIGURED OUT)
    * Deconflate types and modules, UFCS, UMCS, ... (FIGURED OUT)
    * Deterministic name resolution
      * QUESTIONS: is seeing names from outer scopes still deterministic? why?
        what's the precise definition of "deterministic"?
        how to handle autoref/autoderef?
        TODO look at niko's prototype!
    * Closure reform (SUBMITTED BY nikomatsakis)
  # BIC
    * Make inline `mod`s obey normal scoping rules
      inline mods `mod foo { ... }`, out-of-line mods declared `extern mod foo;` (but bikeshed)
      QUESTION require :: to refer to crate root in `use`? or should crate root be the default?
      TODO think this through
    * Closed structs, enums, traits (`abstract struct`, `data struct`, `class`, whatever) (IN PROGRESS)
    ? Remove subtyping and variances (only sublifetimes, but not sub*type*s)
    ? Automatic coercions reform
    * Linear types (QUESTION: unwinding)
    * Parametricity
      * QUESTION: how to reconcile with trait SizeOf<T> { static N: uint } forall types?
        trait SizeOf<T> { static SIZE_OF: uint; }; 
        unsafe fn size_of<T>() -> uint;
        is this a problem for static declarations?
        or just have a `sizeof` operator which is `unsafe`?
      * QUESTION how to deal with Drop? require it explicitly?
    * Checked arithmetic (SUBMITTED)
    * Ban private items in public signatures (ACCEPTED?)
    * Tighten shadowing rules (SUBMITTED BY Kimundi)
    * Enforce capitalization conventions (REJECTED)
    ? *T should be non-nullable (`Option<fn()>` is *already* required in FFI! should just guarantee repr of `Option`-like types.)
    * Syntax wibbles:
        Struct { f: v } -> Struct { f = v }
        #[attr]         -> #attr (BC: allow #attr and #attr(foo), but require #[attr = foo])
        &'a mut Foo     -> &mut 'a Foo
        macro_rules!    -> macro! or define!
        name@pat        -> pat as name
        <'a> |&'a Foo|  -> for<'a> |&'a Foo|
        extern "C"      -> extern C, extern<C>, or extern(C) (SUBMITTED)
        foo::<T>        -> foo@<T>? (remove confusion w/ module scoping)
        'a              -> introduce as `scope a` or `lifetime a`, use as just `a`?
  # IMPORTANT
    * Exception handling a la Either monad (FIGURED OUT)
    * trait Trait1 + Trait2 (PARTIALLY IMPLEMENTED)
    * trait Transmute<T> (SUBMITTED BY gereeter)
    * GC, trait Trace
    * &move
    * &out (SUBMITTED BY gereeter)
    * "Unboxed trait objects" (SUBMITTED BY aturon, POSTPONED) (might be subsumed by EQT!)
    * Type ascription
    * Associated types (SUBMITTED BY aturon)
    * Macro reform
  # MINOR
    * General function-like generics syntax sugar
      type Proc(A) -> R = Box<FnOnce(A) -> R> 
      QUESTION where to put lifetimes
    * UnsafeUnion<A, B>
    * Incoherent empty traits?
    * Associated statics (SUBMITTED BY aturon)
    * Anonymous sum types? (int|bool|char)
    * enum bool { false, true }, all two-nullary-variant enums repr.-ed the same (BIC?)
      generally: guarantee all merely-alpha-renamed structs, tuples, enums repr.-ed the same?
    * Early return from any block
    * Explicit refutable `let`: `let`..`else`
    * Scoped refutable `let`: `if let` (SUBMITTED BY kballard)
    * Expose tuple fields as .0 .1 ... .N (SUBMITTED BY P1Start)
    * Array splicing
    * Fixed-length array slices in patterns (SUBMITTED BY krdln)
    * Destructuring assignment
    * Disjunctive patterns in `let`s (SUBMITTED BY _, POSTPONED)
    * Liberalized destructing struct destructuring
    * Limited type inference for `static` items
    * #compact struct, enum (GH issue)
    * Generalized object literals (closures) for any trait, not just `Fn`* 
        QUESTION syntax! impl-like? closure-like? struct-like?
          let num = 42;
          let obj = object (Show + Hash) {
              show: || num.to_str(),
              hash: || num
          };
          self is implicit! like fn closures
    * for<T1..TN> { ..items.. } (SUBMITTED BY _, POSTPONED)
    * Naming wibbles:
        Any    -> Dynamic
        Arc    -> AtomicRc
        Option -> Maybe, Optional, Nullable
        Void   -> Never
  # FAR FUTURE
    * `static` generics parameters
    * Generic generics parameters (higher-kinded types)
    * Partial type application
    * Trait generics parameters (ConstraintKinds)
    * Kind polymorphism
    * First-class polymorphic types (higher-rank types)
    * Explicit existential quantification syntax
    * Existential quantification in structs
    * Polymorphic recursion
    * `static fn`, CTFE
    * Dependent types a la pigworker
    * Datatype-generic programming (GHC.Generics)
    * Variadic generics
    * TCE
    * Delayed initialization of struct fields? (loop tying)

## QUESTIONS
 * What would break without subtyping for lifetimes?
 * What's the conflict between modules and macros?
 * What are the problems with globs?
 * Why isn't a simple newtype-based design sufficient for HashMap?
 * Is `Arrow` connected to linear logic/types? (To closed (symmetric) monoidal categories?)
 * Is there a description/paper about UHC's implementation of existential types?
 * How can safety of (multiply-)intrusive data structures be proved in general?

## How `box` should work

trait Alloc {
    type Where = ();
    fn alloc<T>(self: &out Self<T>, where: Where) -> &out T;
}

impl Alloc for Box { ... }
impl Alloc for Rc  { ... }
impl Alloc for Gc  { ... }

struct Arena { ... }
struct ArenaRef<'s, T> { ... }

impl<'s> Alloc for ArenaRef<'s, ..> {
    type Where = &'s mut Arena;
    ...
}

`box(where) some_foo` =>
 * type determined by inference
 * type is `B<Foo>` such that: `some_foo: Foo` && `where: Where` && `B: Alloc` && `B::Where = Where`
 * `box some_foo` short for `box(()) some_foo`
 * `B` defaults to `Box`?
 * use type ascription to fix `B` when necessary, e.g. `let boxed_foo: Rc<_> = box some_foo;`, or later `box some_foo: Rc<_>`
   HKT is important so the element type can be inferred with _; otherwise, have to specify whole type!
   question: precedence of `:`?


some_foo: Foo
where: Where
--
box(where) some_foo: forall B: Alloc where B::Where = Where. B<Foo>

box(where) some_foo
=>
{
    let the_box;
    *the_box.alloc(where) = some_foo;
    the_box
}

box some_foo
=>
box(()) some_foo

??
trait Dealloc {
    fn dealloc<T>(self: Self<T>, move_to: &out T);
}
connection to Drop??

## MACRO REFORM
 - #9232
 - fully hygeinic
 - privacy according to defn site
 - _all_ name resolution in macros should happen at the definition site! (syntactic closure!)
 - namespaced like other items
     hard because macro expansion happens before name resolution
     doing them together is allegedly very hard
     could they alternate? make progress as far as possible, then invoke back to the other?
     => a topological "traversal"
     with some kind of restriction to rule out cycles
     is that restriction necessary? analogous to the stage restriction in Template Haskell
     but is that only because TH macros are actual Haskell code which must be compiled, unlike macro_rules!?
        has two parts:
        1. can only use macros imported from a different module (~ different crate requirement for procedural macros in Rust)
        2. top-level splices act as a barrier

## REMOVE SUBTYPING
  or rather, remove the need for variance inference / annotations?
  TENTATIVE PLAN:
    type parameters are always invariant
      use `trait Transmute`, safe-`transmute()` to explicitly coerce compatible types
    lifetime parameters are always contravariant (like `&`)
      is there any use case _whatsoever_ for a closure or fn type where the lifetime of an arg is fixed instead of polymorphic?
      e.g. do you _ever_ want `fn foo<'a>(f: fn(&'a Foo) -> ...)` instead of `fn foo(f: <'a> fn(&'a Foo) -> ...)`?

## TRANSMUTE
 (originally Coercible)
 featherweightmusings.blogspot.hu/2014/03/subtyping-and-coercion-in-rust.html
 no subtyping
 only Transmute trait + variances/roles
 Transmute is explicitly declared for abstract `struct`s, just like the other built-in traits
 three different conversioney things:
   Transmutes:
     zero-runtime-cost reinterpretations
   Automatic coercions:
     those which only involve throwing information away
     casting away concrete types into existentials
     casting numeric types to strictly larger numeric types
       u8  -> u16 i16 u32 i32 f32 u64 i64 f64
       i8  ->     i16     i32 f32     i64 f64
       u16 ->         u32 i32 f32 u64 i64 f64
       i16 ->             i32 f32     i64 f64
       u32 ->                     u64 i64 f64
       i32 ->                         i64 f64
       f32 ->                             f64
     how to extend this to user-defined types?
   Casts with `as`:
     somewhat ad-hoc?
     int-float conversions based on numeric value
       like for hypothetical automatic coercions, but in any direction
     how to extend to user-defined types?
  if T is:
    free          => no conditions
    covariant     => T: Coercible<U>
    contravariant => U: Coercible<T>
    invariant     => T: Coercible<U> && U: Coercible<T>
    fixed         => !
    what about `ref` roles? part of this hierarchy or orthogonal?
      free: always ref
      fixed: never ref
      co, contra, invariant: ?
 instead of variances on type parameters, use generic `Transmute` impls!!
   instead of `struct Foo<bivariant T>`:
     impl<U> Transmute<Foo<U>> for Foo<T>
   instead of `struct Foo<covariant T>`:
     impl<U, T: Transmute<U>> Transmute<Foo<U>> for Foo<T>
   instead of `struct Foo<contravariant T>`:
     impl<U, T: Transmute<U>> Transmute<Foo<T>> for Foo<U>
   instead of `struct Foo<invariant T>`:
     impl<T, U> where T: Transmute<U>, U: Transmute<T> Transmute<Foo<U>> for Foo<T>
   instead of `struct Foo<fixed T>`:
     nothing
   instead of `struct HashMap<K, covariant V>`:
     impl<K, V2, V1: Transmute<V2>> Transmute<HashMap<K, V2>> for HashMap<K, V1>
   `impl<T, U: HasPrefix<T>> Transmute<&U> for &T`
   `impl<T, U: Transmute<T>, static N: uint> Transmute<[U, ..N]> for [T, ..N]`
   mass borrowing would require forall-constraints, but can be done with Skolems
 can this be done entirely as a library?? (except for the auto-deriving and the more-magical built-in impls..?)


## LINKS

GNTD is still not Safe / Inferring Safe is wrong
https://ghc.haskell.org/trac/ghc/ticket/8745
https://ghc.haskell.org/trac/ghc/ticket/8827

FlexibleInstances can be used to violate coherence!!
http://www.reddit.com/r/haskell/comments/2agy14/type_classes_confluence_coherence_global/civ6y1g
TODO port test case to Rust

BitC Lessons For Other Language Developers - Simple vs. Too Simple
http://www.coyotos.org/pipermail/bitc-dev/2012-May/003469.html

Macro import/export
https://github.com/mozilla/rust/issues/3114

Meeting discussion about macros
https://github.com/rust-lang/meeting-minutes/blob/master/Meeting-other-2014-07-16.md

Dependent types!! (pigworker)
http://stackoverflow.com/a/13241158

Full dependent types in Haskell (w/ singletons)
http://lpaste.net/109388

Niko Matsakis's name resolution plan + prototype
https://github.com/nikomatsakis/rust-name-resolution-algorithm

Syntactic closures
http://www.rntz.net/post/intuitive-hygienic-macros.html

GHC kind inference
https://ghc.haskell.org/trac/ghc/ticket/9200

Ways to implement polymorphism
http://www.eecs.harvard.edu/~greg/cs256sp2005/lec15.txt

Ericson2314's modules/traits proposal
https://github.com/Ericson2314/rfcs/blob/master/active/0000-combine-mod-trait.md

TCE
https://mail.mozilla.org/pipermail/rust-dev/2011-August/000711.html
https://mail.mozilla.org/pipermail/rust-dev/2011-August/000700.html
https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html
https://github.com/mozilla/rust/issues/217

Variadic generics / arity polymorphism
http://www.ccs.neu.edu/racket/pubs/NU-CCIS-08-03.pdf
http://www.ccs.neu.edu/racket/pubs/esop09-sthf.pdf
http://www.ccs.neu.edu/racket/pubs/NU-CCIS-08-01.pdf
http://www.ccs.neu.edu/racket/pubs/dissertation-tobin-hochstadt.pdf

Existential types
TODO

Higher-rank types
TODO


## INTRUSIVE DATA STRUCTURES
requires non-moveable types!! ?
what would the ExplicitMove trait look like?
because passing by value (moving) is impossible, pass by &move?
can't actually move out of the &move, but can consume it and copy contents
trait Relocate {
    fn relocate(from: &move Self, to: &out Self);
}
implicit movability is turned off by impl Relocate?
do you ever want Relocate and not Clone?
Relocate is equivalent to a Clone followed by a Drop (but faster)
reason normal movable types + pinning by borrowing it is not suitable:
  if it's borrowed it can't be moved to a new location explicitly either
  `relocate()` maintains dynamic invariants through user code
idea in Rust w/ everything movable is that values can have pointers out from them, but not into them
except in cases where it's statically tracked by the borrow checker
is this also connected to the fact that you can only safely express (sendable) tree structures?
http://www.reddit.com/r/rust/comments/2ac60j/safely_storing_a_selfreference_in_self/ciu7wtw
is this related to arena allocation?
  yeah.. arenas shouldn't be movable
  but maybe that's handled by having `&` references into them?
  but then they're not `Send`, which is the point?
generic functions?? :(
  allow instantiating only `ref T`?
  not quite, because `ref T` can still use &move :(


## &out, &move
 use cases:
  explicit lifetimes (tying together)
  trait objects
  slices
  uniform representation
  flexible timing of returns / moves


## Exceptions
Parts:
 * union types / restricted Any
 * match-on-type
 * `throws Type`, `throw val`
 * `try!`

Union types:
  Either<A, B, C, D>
  Can be any of A, B, C, or D
  Like `Any`, but restricted to a set of listed types
  Represented as (TypeId, UnsafeUnion<...>) (~ enums)
  Either<Types..., T> = Either<Types...> if contains(Types, T)
  T is *implicitly* coerced to Either<..., T, ...>
  can test contained type like with `Any`, or use type-match
  QUESTION what if Types contains trait objects?
    avoid trait object auto-coercing in this case?
  QUESTION what if Types contains a type variable?
    does this work out OK? forbid it?
  QUESTION what if Types contains another `Either`?
    would naively lead to nested TypeIds
    do that? flatten it? forbid it?
    should be able to go from A to Either<A, B, C> *and* from Either<A, B> to Either<A, B, C>...
  QUESTION is this related to OCaml's polymorphic variants?
  (desired renames: Any -> Dynamic, Either -> Any)
  special syntax: (A|B|C), A || B || C, A or B or C, ... ?
    (A|B|C) with `foo is Type` for matching works out OK (no conflict with disjunction patterns)

Type match:
  foo: (int|bool|char)
  match foo {
      i is int => ...
      b is bool => ...
      c is char => ...
  }
  or `i: int =>` (conflict: type ascription), or `i as int =>` (conflict: planned name binding), or `(type int, i) =>` (ok but ugly)
  because set of types is fixed, can check exhaustiveness
  (perhaps also allow this for "unrestricted" Any and require a wildcard?)

Throwing:
  fn foo(Bar) -> Baz throws bool { ... }
  `throw false` has type `!`, argument type checked against `throws` clause
    or throw!(), like fail!()? eh, nicer if first-class
  as with return type, so e.g. `fn foo() throws Box<Any> { throw box 666; }` works
  algebraically isomorphic to returning `Result`, but exception is propagated by default (e.g. by unwinding)
    functions without a `throws` clause, i.e. which don't throw, "throw" `!`, just like functions which don't return "return" `!`
  basically this is making the Either monad a first-class part of the language, just like we've already done with ST and IO
    this feels good!
  contract violations are *not* part of `throws` clause and not catchable!!
    assert/unwrap, array out-of-bounds, RefCell borrow check failure, ...
  having to add `throws` to type of `fn` pointers, and additional typaram to `Fn` traits, e.g. `trait Fn<Args, Ret, Err>`
    in surface syntax sugar, Ret defaults to `()` if `->` omitted, and Err to `!` if `throws` omitted
    this seems reasonable and well-contained

Catching:
  `fn try<T, E, Body: (|| -> T throws E) + Send>(body: Body) -> Result<T, E>`
  task-like isolation, exception safety
  `try! { ... }` => `try(|| { ... })`
  also inverse: `fn throw_err<T, E, Body: || -> Result<T, E>>(body: Body) -> T throws E`
  `try` and `throw_err` witness the isomorphism between `-> A throws B` and `-> Result<A, B>`
  choose one or the other based on ergonomics

Put it all together:
  fn some_op(arg: int) -> String throws (IoError|NetworkError) { ... }
  fn other_op(arg: int) throws IoError {
      let res = try! { some_op(arg) };
      match res {
          Ok(s) => println!("ok: {}", s),
          Err(ne is NetworkError) => println!("net err: {}", ne),
          Err(ie is IoError) => throw ie
      }
      // some_op(arg); error: can't throw NetworkError
      // throw 9i; error: can't throw int
  }
  have to list throwable type(s) explicitly, type error if you try to throw something not listed, but propagation is implicit
  could possibly work on syntax more (`match try! { ... } { ... }` looks weird), but this is quite tolerable
  (unhandled errors are rethrown explicitly... not sure if this is a problem)
  various parts are orthogonal:
    can do `throws`, `throw`, and `try` without union types and type-match to get just the automatic propagation
    can do just `(A|B|...)` / Either<A, B, ...> and type-match and use it with `-> Result<Foo, (A|B|C)>` for just the automatic coercion
    but probably need both to make it really seamless
      e.g. if have just throwing, need to use enums in return type and catch-and-rethrow to embed, or trait objects (`Box<Any>`) which allocate
      if just union types, need to return `Ok()` and use (current incarnation of) `try!` everywhere


## QUESTIONS
- "optimize out" references to zero-sized structs?
  - can't literally make the references themselves zero-sized, but...
  - it's guaranteed that no actual data will ever be read from them
  - ditto for references to uninhabited types?
  - therefore they can just be treated as `undef`
  - moved to the end of function argument lists and not actually passed in
  - moved to the end of structs and not considered for `sizeof`?
  - is there anywhere this evilness is observable?
    - would anyone care if sizeof((A, B)) >= sizeof(A) + sizeof(B) breaks?
    - what about `ptr_eq`?
    - unsafe code transmuting the type there and back would expect the reference to stay valid
      - e.g. with pointers to opaque types in FFI
        - would they ever use `&mut Thing` or `&Thing`, or just `*Thing`?
        - probably would... ?
      - perhaps only do this for _either_ zero-sized or uninhabited references, but not both?
      - &Void and &mut Void are inherently unsound!
      - or more like: only for `data struct`s? (and `data enum`s?)
      - then I think we only have the `ptr_eq` problem
- can stack maps / stack tracing also be used for relocatable stacks? (why not?)
    have a map of all non-heap refs/pointers on the stack
    what about *T?!
    any of these which point to an address inside the stack are incremented with the offset to the new stack
- what should a not-fully-general Drop or Trace impl mean?
    A: not-covered types should have glue as normal, just not the impl
    B: a not-covered type is illegal
    given A, then B can be expressed with a smart constructor
      also allow trait bounds on struct typarams?
      only covers the case where Drop is restricted to a trait, not to a type (requires an (~) constraint)
      think this should be a separate feature
- is there any way to give a safe type signature to `alloca`, with e.g. &out?
- `let x = ...; let y = &move x; x = *y;` seems like it should be OK? saying "actually, don't destroy it after all"
    can this be shown safe in general?
  is there an analogue for `&out`?
  `let x; let y = &out x; ???`?
- how to relate `trait Foo<T>` + `impl<T> Foo<T> for My<T>` and `trait Foo for type<type> Self` + `impl Foo for My`?
    trait GBox for type<type> Self where for<T> Box<Self<T>> ???
    class forall a. Box (b a) => GBox b
- how to specify subtyping nicely?
  http://www.reddit.com/r/haskell/comments/1u9pbw/feedback_sought_a_typetheoretic_account_of/ceg4cos
- how to do TCE?
  TCE calls are always explicit
  if moves/drops are tracked statically, and TCE is explicit, those are no problem
    static error in case of conflict
  problem: calling conventions
    C convention: caller cleanup
    we need: callee cleanup
    QUESTION where do we need it?
        "The problem seems to be that you can't do tail calls with the C calling convention.
        For example, let's say a 0-argument function tail calls a 1-argument one: the 1-argument function expects an argument on the stack, so the 0-argument function must push one.
        However, when the 1-argument function returns, the argument will still be on the stack, because with the C calling convention the caller removes arguments from the stack.
        But the caller called a 0-argument function, so he won't remove any argument, and thus the stack is now misaligned due to the argument left over there, which will crash the program soon.
        However, just switching to the Pascal/stdcall convention, where the callee removes arguments from the stack should just work; it might be slightly slower, but on all modern architectures (i.e. those that aren't x86-32) parameters are going to be passed in registers anyway for must functions, so it shouldn't matter.
        The problem of that is that non-varags functions cannot be called with a varargs prototype; this is an issue with K&R C that allows calling undeclared functions, but isn't an issue with Rust.
        So, I'm not quite sure why Rust doesn't just switch calling conventions and support tail calls."
  solution:
    make a callee-cleanup wrapper around every fn
    always at a fixed offset
       should always be 2 insns: call f; ret N;
    TCE calls take the offset before calling
    but it's the last call that needs to be caller-cleanup, not the first...?
    more precisely:
      f calls g, g tail-calls h, then:
      f (not g) needs to know that g will do TCE?
      h (not g) needs to know that g will do TCE?
  or alternately:
    don't actually do tail calls, just re-use own stack for arguments of callee
    not complete because return pointer is still added to stack
  what should the keyword be? go? in? out? tail? goto? self? use?
    "Tail calls can be made explicitly in Perl, with a variant of the "goto" statement that takes a function name: goto &NAME;"
      http://perldoc.perl.org/functions/goto.html
    interacts how with explicit/implicit return?
    `return` is always tail unless followed by drops?
- how to do variadic generics?
  C++ solution is too "big" and complex
  primary use case: abstracting over # of fn parameters
  but also need to 'splice', e.g. for `trait Fn`
  also would be nice: type c_union<type..>
  how might Applicative look?
  interaction with HKT?
    is a variadic parameter its own kind?
    interaction with type inference?
  is everything either a map or a fold? do we need explicit recursion?
    what contexts are maps, folds, splices allowed in?
  which parts of C++11 variadics does Rust need, which parts are handled in other ways, which parts are out of scope?
    do we only need it for types, or also non-types and HKTs?
  is providing variadic args implicit like C++, or explicit? e.g. c_union<[int, char]>
    have explicit syntax, allow sugar when it's unambiguous?
  but that's essentially tuples... would deconstructing, mapping, and splicing tuples be enough?
  USE CASES:
    trait Fn, FnMut, etc.
    typedefs for same
    c_union
    trait Applicative?
    variadic tuple structs
    StructF, EnumF, ComposeF?
- how to do higher-rank types?
  QML, HML, HMF, MLF, FPH, bidirectional, "Practical type inference..."
  HML < HMF < MLF
  others: ??
  "It's very easy to extend the system with annotations for polymorphic applications. However, this makes it more complicated to explain which program transformations preserve typability. Basically, you get to pick any two of: (a) impredicativity, (b) preservation of typability under eta, and (c) the usual type language of System F. We chose (b) and (c) in this paper, MLF picks (a) and (b), and HMF/FPH pick (a) and (c)."
- GeneralizedGeneralizedNewtypeDeriving? not just for newtypes, but any two Coercible types?
    impl the trait for tuples + anonymous sums -> newtype-derive it for representationally compatible types
  (doesn't work where the names of types, fields, and variants are relevant)
- are enums just existentially quantified somethings? (yes)


## misc features
 - short-circuiting ptr-equality comparison for `impl Eq for &`?
   needs some kind of magic because of PartialEq, e.g. &NaN != &NaN even if address-equal
 - attributes to specify type class laws.. or first-class language feature? (not just for type classes)
 - Allow inferred type-wildcards in `impl` method signatures?
 - `fn swap<T>(self: &Cell<T>, other: &mut T)`? (no `Copy`!)
 - `EXPR is PAT: bool` operator
 - currying: foo(1) if foo is a two-arg callable thing returns a one-arg callable thing
 - refutable patterns in for loops
 - destructuring in assignments
 - array splicing [1, 2, ..arr] [..[1, 2, 3], 4, 5, ..[6, 7], 8, 9, ..[10]]
 - early return from any block: return 's val? break 's val?
   (default for `break` is innermost loop. is that intuitive? for `return` is outermost block.. `'fn`)
 - compacted enum? no interior pointers => stronger optimization
   also compacted struct!
   no interior pointers? or:
    - only & pointers, contents are copied out onto the stack
    - also &mut pointers, contents are copied out, and copied back at end of borrow
   if all interior refs are allowed, no problem with just being a #compacted attr!
   might fulfill many/most use cases for manual bit twiddling
       #compacted
       struct Flags { a: bool, b: bool, c: bool, ... }
       sizeof!(Flags) == 1
   could also take advantage of tag bits in pointers, i31, ... go crazy
 - allow type inference of locally declared fns and statics?
 - deriving Functor, Bifunctor, Profunctor, .. ?
 - all built-in types just sugar
   - lang items?
   - & => Ref, Borrowed, ..
   - &mut => RefMut, BorrowedMut, ..
   - ~ => Owned, My, ..
   - [T, ..N] => Array<T, ..N>
   - str becomes a library type(?)
   - numeric types -> lang items?
 - defined-length vec slices in patterns
   - [ref a, ..{N} mut ref B]
   - [ref a, ..N as mut ref B]
   - ...
 - let .. else ..
   - also important to enable let [mut ref a, ..] = ...
 - ! as first class type (! is just forall a. a!)
 - allow disjunctive patterns in lets?
 - anonymous sum types
 - DefaultSignatures
 - unsafe traits and and unsafe impls? (can break variant that isn't directly unsafe, but other thing relies on it for safety)
 https://github.com/mozilla/rust/issues/8409
 - BIC? modular 'unsafe'? unsafe(memory), unsafe(array), unsafe(overflow), unsafe(rc_cycles), unsafe(concurrency)
   - would require mapping the dependencies
 - unsafe overlapping/incoherent impls, assumed confluent?

## Lazy<T>
- for any given function with a parameter Rust wants a version where it's a value, and one where it's a closure
- Haskell values are lazy, so it gets away with a single definition
- ...whereas these Rust versions would want to use `once fn`s
- a lazy value only gets evaluated once
- blackholing ~ borrow checking? (RefCell)
- are unboxed closures w/o arguments basically the same thing as expressions? 
- the FnOnce bound should only be necessary for constructing!
- in: FnOnce, out: FnMut (Fn??)

pub struct Lazy<F, T> {
    eval: fn(&mut Lazy<F, T>) -> &mut T,
    data: UnsafeUnion<F, T>
}

impl<F: Copy, T: Copy> Copy for Lazy<F, T> { }
impl<F: Send, T: Send> Send for Lazy<F, T> { }
what about Share?
??? impl<F, T, U: Transmute<T>> Transmute<Lazy<F, U>> for Lazy<F, T> { }

pub fn lazy<T, F: FnOnce() -> T>(closure: F) -> Lazy<F, T> {
    Lazy {
        eval: eval_force::<T, F>,
        data: unsafe { transmute(closure) }
    }
}

pub fn eval<T>(self: &mut Lazy<T>) -> &mut T {
    (self.eval)()
}

?? pub fn eval_share<T, F: Fn() -> T>(self: &Lazy<F, T>) -> &T;

pub fn unwrap<T>(self: Lazy<T>) -> T {
    self.eval();
    unsafe { transmute(self.data) }
}

fn eval_force<T, F: FnOnce() -> T>(self: &mut Lazy<F, T>) {
    *self = Lazy {
        eval: eval_noop::<F, T>,
        data: unsafe { transmute(transmute::<_, F>(self.data)()) }
    };
    eval_noop(self)
}

fn eval_noop<F, T>(self: &mut Lazy<F, T>) -> &mut T {
    transmute(&mut self.data)
}

impl Functor, Applicative, Monad, Comonad

impl Fn{,Mut,Once}:
  return T: unwrap? Copy? Clone?
  return &mut T?

or impl Deref{,Mut,Move}?



QUESTION Lazy<F, T> or Lazy<T, F>?
 - implicit existential quantification
 - partial type application for Functor etc.
 This seems to suggest Lazy<F, T>...
 Should the Functor instance be forall F or exists F?
 ...certainly seems like exists would be correct!
 In that case, does partial type application still matter?
 Is there a relationship between p.t.a. and i.e.q.?

QUESTION when can we allow `eval()` through shared references?
  I think GHC's blackholing corresponds directly to RefCell, and <<loop>> to a borrow failure
  Can we avoid RefCell if we require Fn (pure) instead of FnOnce?

QUESTION (how) can we allow `eval()` in pure code?
  By requiring `Fn` instead of `FnOnce`?
  Bifurcate into `Lazy` and `PureLazy`, or just require `Fn` at the `eval()` site (eval_share)?
  Can we have an existential of `Lazy` produced by `lazy_pure()` where we know it supports `Fn`, without duplicating everything, and without carrying runtime evidence?

QUESTION how can we `eval()` from multiple threads?
  By requiring Fn?
  By using some thread-safe version of RefCell? (look into how blackholing works!)


## UnsafeUnion<A, B>
  sizeof(UnsafeUnion<A, B>) = max(sizeof(A), sizeof(B))
  alignof(UnsafeUnion<A, B>) = lcm(alignof(A), alignof(B))
  unsafe_transmute
    A -> UnsafeUnion<A, B>
    B -> UnsafeUnion<A, B>
    UnsafeUnion<A, B> -> A
    UnsafeUnion<A, B> -> B
  if {x, y}: UnsafeUnion<A, B>, *x = y is unsafe!! destructors don't run
     should it be a linear type??
  impl<A: Copy, B: Copy> Copy for UnsafeUnion<A, B>
  -- or just impl Copy for UnsafeUnion<A, B>?? or a disjunction??
  likewise Share, Send, etc.
  UnsafeUnion<_, _> is idempotent, commutative, associative
  so we can just define UnsafeUnion3<A, B, C> = UnsafeUnion<A, UnsafeUnion<B, C>>
    this is where constructor = transmute, instead of plain fn, would be important
  with type macros perhaps UnsafeUnion!(A, B, C, D)


## TYING THE KNOT

fn tie<T>(build: |Gc<T>| -> T) -> Gc<T>
{
    
}

struct Stream<T> { head: T, tail: Gc<Stream<T>> }

fn repeat<T>(val: T) -> Gc<Stream<T>>
{
    tie(|tail| Stream { head: val, tail: tail } /* tail not yet initialized here!! :( */)
}

use Box<Lazy<T>>? (Rc/Gc+RefCell?)

use a type-based HKT approach? 
instead of `Gc`, parameterize it, is one opaque type while constructing/tying, becomes Gc once knot is tied


## Trait names

// Semigroup
trait Combine<T> {
    fn combine(a: T, b: T) -> T;
}

// Monoid
trait CombineWithUnit<T: Combine> { // ??
    fn unit() -> T;
}

// Functor
trait Map<F> { // abstract over fn type??
    fn map<A, B>(a: F<A>, f: &Fn(A) -> B) -> F<B>;
}

// Contrafunctor
trait Contramap<F> { // ??
    fn contramap<A, B>(a: F<A>, f: &Fn(B) -> A) -> F<B>;
}

// Applicative
trait Apply<F: Map> { // Sequence? Map2? Multimap?
    fn wrap<A>(a: A) -> F<A>;
    fn unit() -> F<()>;
    fn map2<A, B, C>(a: F<A>, b: F<B>, f: &Fn(A, B) -> C) -> F<C>;
    fn pair<A, B>(p: (F<A>, F<B>)) -> F<(A, B)>; 
    fn apply<A, B>(f: F<&Fn(A) -> B>, a: F<A>) -> F<B>;
}

// Monad
trait Flatten<F: Apply> {
    fn flatten<T>(a: F<F<T>>) -> F<T>;
    fn and_then();
}

// Comonad
trait Unflatten<F: Apply> {
    fn unwrap<T>(a: F<T>) -> T;
    fn unflatten<T>(a: F<T>) -> F<F<T>>;
}

// Foldable
trait Fold<C> { // ?? Reduce? Summarize? Process? Condense? Digest?
    fn fold<A: CombineWithUnit>(a: C<A>) -> A;
    fn foldMap<A>(a: C<A>, map: &Cn(A) -> B, combine: &Cn(B, B) -> B) -> B;
}

// Traversable
trait Traverse<C: Map + Fold> { // ?? 
    fn sequence<T, F: Apply>(a: C<F<T>>) -> F<C<T>>;
    fn traverse();
}

// Semigroupoid
trait Compose<Cat> {
    fn compose<A, B, C>(a: Cat(A) -> B, b: Cat(B) -> C) -> Cat(A) -> C;
}

// Category
trait ComposeWithIdentity<Cat: Compose> { // ??
    fn identity<A>() -> Cat(A) -> A;
}

// Profunctor?? Bifunctor? InvFunctor?

// use "transform" for something?


## Mass borrowing with Transmute

//impl<'s, T> Transmute<&'s R<&'s T>> for &'s R<Box<T>> { }
//impl<'s, T, type<covariant type> R> Transmute<&'s mut R<&'s mut T>> for &'s mut R<Box<T>> { }
//impl<'s, 't, T, type<covariant type> R> Transmute<&'s R<&'t T>> for &'s R<&'t mut T> { }

impl<'s, T, type<type> R> 
    where for<A, B: Transmute<A>> R<B>: Transmute<R<A>> 
    Transmute<&'s R<&'s T>> for &'s R<Box<T>> { }

class SkolemA;

class SkolemB { x: SkolemA }

impl Transmute<SkolemA> for SkolemB { }

impl<'s, T, type<type> R>
    where R<SkolemB>: Transmute<R<SkolemA>>
    Transmute<&'s R<&'s T>> for &'s R<Box<T>> { }


## Misc 

Interesting project: once Rust has `Trace` GC, implement a Haskell compiler/runtime piggybacking off of it?
  Desugar Haskell to Rust?
    every type just becomes Gc<Lazy<T>>?? what about threads?
    what about currying?
  Merely Haskell-like syntax for Rust, keeping Rust semantics?

Interesting project: mechanically translate C to Rust with *const T, *mut T, `unsafe`
  problematic bits:
    goto
    switch with fallthrough?
  next step: determine where * can safely be replaced with & (...what other things?)

Interesting project? mechanically translate Rust to C
  is there any point to this, given Rust has a C FFI?


vReplicate :: (PI n :: Nat) -> x -> Vec n x
vReplicate Z     x = VNil
vReplicate (S n) x = VCons x (vReplicate n x)

vReplicate :: forall (n :: Nat). x -> Vec n x
vReplicate = case (reflect @ n) of
    Z x => VNil

reflect :: forall (n :: Nat). Nat

lens lib -> opticks, CT lib -> abstract-nonsense

groupoid      <-> equivalence relation
idempotence   <-> reflexivity
commutativity <-> symmetry
associativity <-> transitivity
what's the precise relationship here


## No privates in public

OK:

mod m {
    pub struct S;
}
pub use m::S;
pub fn f() -> S;


Not OK:

mod m {
    pub struct S;
}
pub fn f() -> m::S;


struct S; 
mod m { 
    pub fn f() -> S; 
} 
pub use f = m::f;`


struct S; 
pub mod m { 
    pub fn f() -> S; 
} 




## Things I wrote
TODO sort

`static fn`
http://www.reddit.com/r/rust/comments/2e76zs/rust_as_a_host_for_multilevel_languages_using/cjxdrd5

Linear types
http://www.reddit.com/r/rust/comments/2b02mb/rust_will_be_the_language_of_the_future/cj1sbcq
http://www.reddit.com/r/rust/comments/2b02mb/rust_will_be_the_language_of_the_future/cj8n5zf

Abstract over `&` and `&mut` via a built-in higher-kinded `Reference` trait
http://www.reddit.com/r/rust/comments/2a721y/a_safe_way_to_reuse_the_same_code_for_immutable/cj8pebl

Zero-sized tokens as evidence
http://www.reddit.com/r/rust/comments/1wvxcn/lazily_initialized_statics/cf61im5

Scoped attributes for checked arithmetic
https://github.com/rust-lang/rfcs/pull/146

Change `extern "ABI"` syntax
https://github.com/rust-lang/rfcs/pull/156

`abstract struct`, `abstract enum`
https://github.com/rust-lang/rfcs/pull/10

No privates in public
https://github.com/rust-lang/rfcs/pull/136

Enforce capitalization rules
https://github.com/rust-lang/rfcs/pull/154

`for` = forall
https://github.com/rust-lang/rfcs/pull/157

`Transmute` née `Coercible`
https://github.com/rust-lang/rust/issues/9912#issuecomment-36073562
https://github.com/rust-lang/rfcs/pull/91
https://github.com/rust-lang/rfcs/pull/91#discussion_r13057612
https://github.com/rust-lang/rfcs/pull/91#issuecomment-46834744
https://github.com/rust-lang/rfcs/pull/91#issuecomment-50234451

`MaybeOwned`, `CopyOnWrite` (-> `MaybeUnique`, `MakeUnique`)
https://github.com/rust-lang/rust/pull/11230#issuecomment-32708787

GC, `Trace`
https://github.com/rust-lang/rust/pull/11399#issuecomment-33124755
https://github.com/rust-lang/rust/pull/11399#issuecomment-33310724
https://github.com/rust-lang/rust/pull/11399#issuecomment-34439765
https://github.com/rust-lang/rust/pull/11399#issuecomment-33756578
https://github.com/rust-lang/rust/pull/11399#issuecomment-33930506

Unboxed trait objects
https://github.com/rust-lang/rust/issues/11455
https://github.com/rust-lang/rfcs/pull/105
https://github.com/rust-lang/rfcs/pull/105#issuecomment-45096279
https://github.com/rust-lang/rfcs/pull/105#issuecomment-47545719

Deterministic name resolution
https://github.com/rust-lang/rust/issues/11878

`&out`
https://github.com/rust-lang/rust/issues/10672#issuecomment-32342797
https://github.com/rust-lang/rfcs/pull/98
https://github.com/rust-lang/rfcs/pull/98#issuecomment-44788950
https://github.com/rust-lang/rfcs/pull/98#issuecomment-46036846
http://www.reddit.com/r/rust/comments/2b02mb/rust_will_be_the_language_of_the_future/cj94b1c

`UnsafeUnion`
https://github.com/rust-lang/rfcs/pull/197#issuecomment-52054190

Anonymous sum types
https://github.com/rust-lang/rust/issues/8277

Generalized destructing struct destructuring
https://github.com/rust-lang/rust/issues/11855

#compact `struct`, `enum`
https://github.com/rust-lang/rust/issues/12642

`impl<T: Copy> Copy for &mut T`
http://discuss.rust-lang.org/t/impl-t-copy-copy-for-mut-t/414

`swap` for `Cell`
http://discuss.rust-lang.org/t/a-swap-method-for-cell/392

